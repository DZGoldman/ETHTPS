@inject ETHTPS.API.Infrastructure.Database.Models.ETHTPSContext _context;
@using System.Linq;
@using Newtonsoft.Json;
<div>
    <div id="intervals-container" style="float:right;">

    </div>
    <canvas id="stackedChart" width="400" height="300"></canvas>
</div>
<script>
    function intervalFormat(interval) {
        switch (interval) {
            case "OneHour":
                return "1h";
            case "OneDay":
                return "1d";
            case "OneWeek":
                return "1w";
            default:
                return interval;
        }
    }

    for (interval of config.Intervals) {
        if (interval === "Instant" || interval === "Latest") {
            continue;
        }
        let id = `interval-btn-${interval}`;
        $("#intervals-container").append(`<button type="button" id="${id}" class="btn btn-light">${intervalFormat(interval)}</button>`);
        $(`#${id}`).on('click', function () {
            config.selectedInterval = $(this).attr('id').replace('interval-btn-', "");
            redrawStackedChart();
        });
    }
    config.selectedInterval = "OneHour";
    var dateMap = config.ChartData.Data.flatMap(d => d.Groups.flatMap(q => q.Data.flatMap(r => r.Date)));

    function getDataFor(provider) {
        for (dataEntry of config.ChartData.Data) {
            if (dataEntry.Provider === provider) {
                return dataEntry.Groups.filter(x => x.Interval === config.selectedInterval).flatMap(x => x.Data);
            }
        }
        return [];
    }

    function getColorFor(provider, offset) {
        for (let i = 0; i < config.Providers.length; i++) {
            if (config.Providers[i] === provider) {
                return colors[(i + offset) % colors.length];
            }
        }
    }
</script>
<script>
    var stackedChart = null;
    function redrawStackedChart() {
        if (stackedChart !== null) {
            stackedChart.destroy();
        }
        var ctx = document.getElementById("stackedChart").getContext("2d");

        function createLine(provider) {
            return {
                label: provider,
                fill: false,
                backgroundColor: getColorFor(provider, 0),
                pointBackgroundColor: getColorFor(provider, 1),
                borderColor: getColorFor(provider, 1),
                pointHighlightStroke: getColorFor(provider, 1),
                borderCapStyle: 'butt',
                data: getDataFor(provider).map(x => x.TPS),
                tension: 0.3,
                hoverOffset: 4
            }
        }

        stackedChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: getDataFor(config.Providers[0]).map(x => x.Date),
                datasets: config.Providers.sort((a, b) => Math.max(getDataFor(a)) - Math.max(getDataFor(b))).map(x => createLine(x))
            },
            options: {
                responsive: true,
                elements: {
                    point: {
                        radius: 0
                    }
                },
                scales: {
                    yAxes: [{
                        stacked: true,
                    }],
                    xAxes: [{
                        gridLines: {
                            display: false
                        },
                        ticks: {
                            display: false //this will remove only the label
                        }
                    }]
                },
                animation: {
                    duration: 750,
                }
            }
        });
    }
    redrawStackedChart();

</script>